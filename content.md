Of course. Creating a focused regression test is the critical first step. It will precisely define the correct behavior and act as a permanent safeguard.

I will create a new integration test file that specifically targets the two identified failure modes:
1.  **Standard Imports**: Symbols imported from external libraries (`typing.Dict`, etc.).
2.  **Re-exports**: Symbols imported from another local module and exposed in an `__init__.py`.

This test will fail with the current logic and pass once the fix is implemented.

## [WIP] test: Add regression test for re-exports and standard imports

### 用户需求

`stitcher check` incorrectly reports missing documentation for both standard library imports (e.g., `Dict`) and local re-exports (e.g., a class imported into an `__init__.py`). A regression test is needed to formalize the expected behavior: `check` must ignore both.

### 评论

This is the correct approach. The previous test `test_check_ignores_imports` was a good start but didn't cover the re-export scenario, which is a common and important pattern in Python packages. This new, more comprehensive test will solidify the fix and prevent future regressions in either scenario.

### 目标

1.  Create a new integration test file: `packages/stitcher-application/tests/integration/test_check_ignores_reexports.py`.
2.  In this test, construct a workspace with a multi-file package structure:
    *   `src/my_lib/defs.py`: Defines a public class `MyDefinedClass`.
    *   `src/my_lib/__init__.py`: Imports `MyDefinedClass` (re-export), `Dict` (standard import), and defines a local public function `my_local_function`.
3.  Execute `stitcher check` on this workspace.
4.  Assert the following:
    *   **MUST** report `my_local_function` as missing documentation.
    *   **MUST NOT** report the re-exported `MyDefinedClass` as missing documentation in `__init__.py`.
    *   **MUST NOT** report the standard import `Dict` as missing documentation.

### 基本原理

This test directly simulates the project structure that reveals the core flaw in the symbol analysis logic. By using `SpyBus`, we can precisely inspect the semantic messages generated by the `check` command. The assertions will verify that the analysis correctly distinguishes between symbols *defined* in a file versus those merely *referenced* via import, regardless of whether the source is another local module or the standard library.

### 标签

#intent/tooling #intent/fix #flow/ready #priority/high #comp/tests #scope/dx #task/domain/testing #task/object/check-command #task/action/bug-fix #task/state/continue

---

### Script

#### Acts 1: 创建回归测试文件

I will now create the new test file. It will set up the workspace as described and contain the specific assertions to enforce the correct behavior.

~~~~~act
write_file
packages/stitcher-application/tests/integration/test_check_ignores_reexports.py
~~~~~
~~~~~python
import pytest
from needle.pointer import L
from pathlib import Path

from stitcher.test_utils import WorkspaceFactory, SpyBus, create_test_app


def test_check_ignores_reexports_and_imports(tmp_path: Path, monkeypatch):
    """
    Verifies that 'stitcher check' correctly ignores:
    1. Symbols re-exported from another module in the same package.
    2. Standard library imports.
    It should only flag symbols physically defined in the file being checked.
    """
    # 1. Setup: Create a project with a re-export structure
    workspace_factory = WorkspaceFactory(tmp_path)
    spy_bus = SpyBus()
    ws = (
        workspace_factory.with_config({"scan_paths": ["src"]})
        .with_source(
            "src/my_lib/defs.py",
            """
class MyDefinedClass:
    '''This class has a docstring.'''
    pass
            """,
        )
        .with_source(
            "src/my_lib/__init__.py",
            """
from typing import Dict
from .defs import MyDefinedClass  # This is a re-export

# This function is locally defined and should be reported
def my_local_function():
    pass
            """,
        )
        .build()
    )

    # 2. Execution: Run the check command
    app = create_test_app(ws)
    with spy_bus.patch(monkeypatch):
        app.run_check()

    # 3. Assertion: Verify the output from the bus
    messages = spy_bus.get_messages()
    
    print("\n=== Captured Bus Messages ===")
    for msg in messages:
        print(f"[{msg['level'].upper()}] {msg['id']}: {msg.get('params', {})}")
    print("=============================")


    missing_doc_warnings = [
        msg for msg in messages if msg["id"] == str(L.check.issue.missing)
    ]

    reported_keys = {
        (msg["params"]["key"], msg["params"].get("path"))
        for msg in missing_doc_warnings
    }
    
    # Assert that the locally defined function IS reported as missing
    assert (
        "my_local_function",
        "src/my_lib/__init__.py",
    ) in reported_keys, "Local function was not reported as missing."

    # Assert that standard imports and re-exports are NOT reported
    assert (
        "Dict",
        "src/my_lib/__init__.py",
    ) not in reported_keys, "Standard import 'Dict' was incorrectly reported."
    
    assert (
        "MyDefinedClass",
        "src/my_lib/__init__.py",
    ) not in reported_keys, "Re-exported class 'MyDefinedClass' was incorrectly reported."

    # Assert that the total number of missing doc warnings is exactly 1
    assert (
        len(reported_keys) == 1
    ), f"Expected 1 missing doc warning, but found {len(reported_keys)}: {reported_keys}"

~~~~~

### 下一步建议

The test is now in place. I will execute it, and it is expected to fail. The failure output will confirm our analysis. Following that, I will proceed with implementing the fix in `stitcher-spec` and `stitcher-application` to make this test pass.
